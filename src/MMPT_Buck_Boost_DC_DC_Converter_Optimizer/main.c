 /*******************************************************************************
  Copyright (c) 2015, Infineon Technologies AG                                 **
  All rights reserved.                                                         **
                                                                               **
  Redistribution and use in source and binary forms, with or without           **
  modification,are permitted provided that the following conditions are met:   **
                                                                               **
  *Redistributions of source code must retain the above copyright notice,      **
  this list of conditions and the following disclaimer.                        **
  *Redistributions in binary form must reproduce the above copyright notice,   **
  this list of conditions and the following disclaimer in the documentation    **
  and/or other materials provided with the distribution.                       **
  *Neither the name of the copyright holders nor the names of its contributors **
  may be used to endorse or promote products derived from this software without**
  specific prior written permission.                                           **
                                                                               **
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  **
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    **
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   **
  ARE  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   **
  LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         **
  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF         **
  SUBSTITUTE GOODS OR  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    **
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN      **
  CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)       **
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   **
  POSSIBILITY OF SUCH DAMAGE.                                                  **
                                                                               **
  To improve the quality of the software, users are encouraged to share        **
  modifications, enhancements or bug fixes with Infineon Technologies AG       **
  dave@infineon.com).                                                          **
                                                                               **
 ********************************************************************************
 **                                                                            **
 **                                                                            **
 ** PLATFORM : Infineon XMC1300 Series                                         **
 **                                                                            **
 ** AUTHOR : Application Engineering Team                                      **
 **                                                                            **
 ** version 4.1.4  Initial version                                             **
 ** version 4.2.4  Modified for APP updates(ADC_MEASUREMENT_ADV to productive) **
 **                                                                            **
 ** MODIFICATION DATE : May 03, 2016                                           **
 **                                                                            **
 *******************************************************************************/
/*
 * Classic voltage buck control implementation which measures the output voltage with an ADC channel ,
 * calculates the error to a target output voltage value, implements a compensator in software
 * and applies the changes to the PWM generated by the CCU8.
 *
 *
 */

/*Including DAVE.h for generated code and xmc_3p3z_filter_fixed.h for the filter implementation */
#include <DAVE.h>
#include "xmc_3p3z_filter_fixed.h"

#define cFalse	(0 != 0)
#define cTrue  	(0 == 0)

/******************************************************************************************
 * These are the raw float values for the filter coefficients,
 * VADC reference and maximum and minimum values desired for the PWM duty cycle
 *
 * These coefficients has been selected to have the following controller characteristics:
 * + Switching freq = 100kHz
 * + Crossover freq = 5kHz
 * + Phase margin   = 50 degrees
 * + PWM resolution = 15.625 ns
 * + ADC resolution = 12 bits
 *
 */
/*#define B0 (+0.649757898241)
#define B1 (-0.582384858571)
#define B2 (-0.649256971688)
#define B3 (+0.582885785125)
#define A1 (+1.335491183190)
#define A2 (-0.211704021559)
#define A3 (-0.123787161631)
#define K (+0.657007535988)
#define REF (1172) //ADAL changed from 3215 to 782=20V, 1168=30V
#define DUTY_TICKS_MIN (0)
#define DUTY_TICKS_MAX (576)*/

// TODO: Fix the regulator to work properly in both Buck and Boost modes
#define B0 (+0.080646088661)
#define B1 (-0.068450008673)
#define B2 (-0.080597564936)
#define B3 (+0.068498532398)
#define A1 (+1.228518509846)
#define A2 (-0.128482591507)
#define A3 (-0.100035918339)
#define K (+1.0 )//K (+2.709991763927)
#define REF (755) //VOUT=20V
//#define REF (1125) //VOUT=30V
//#define REF (3000) //VOUT=30V @150kHz
//#define REF (389) //VOUT=10V
#define DUTY_TICKS_MIN (0)
#define DUTY_TICKS_MAX (307)

/*#define B0 (+1.705582)
#define B1 (-1.325943)
#define B2 (-1.684457)
#define B3 (+1.347069)
#define A1 (-0.198316)
#define A2 (+0.981550)
#define A3 (+0.216765)
#define K (+8.216995)
#define REF (+1168)
#define DUTY_TICKS_MIN (+0)
#define DUTY_TICKS_MAX (+288)*/
/**********************************************************************************************/

/* The VADC conversion is being triggered by the compare match 2, which is configured to the period value.
 * Please modify the TRIGGER_ADC value to modify the trigger point within the timer period */
#define PWM_PERIOD   						PWM_CCU8_0.config_ptr->period_value
#define TRIGGER_ADC  						PWM_PERIOD
#define PWM_CCU8_0_SHADOW_TRANSFER_ENABLE	(0x1)
#define PWM_CCU8_1_SHADOW_TRANSFER_ENABLE	(0x10)

#define PWM_START_UP_DELAY_CNT				(100000U)

/* VADC voltage transfer function */
#define mGET_ADC_VALUE_BY_INPUT_VOLTAGE(voltage) \
	(voltage * 0.025 * 4096) / 3.3
#define mGET_ADC_VALUE_BY_OUTPUT_VOLTAGE(voltage) \
	(voltage * 0.0313 * 4096) / 3.3
#define mGET_ADC_VALUE_BY_OUTPUT_VOLTAGE_PROTO(voltage) \
	(voltage * 0.0306 * 4096) / 3.3

/* Voltage limits */
#define MIN_INPUT_VOLTAGE	(15U)
#define MAX_INPUT_VOLTAGE	(60U)
#define MAX_OUTPUT_VOLTAGE	(60U)

#define VOLTAGE_REF			(20U)
#define MODE_HYSTERESYS		(2U)

typedef enum ConverterMode_t
{
	Buck = 0,
	Boost = 1,
	Buck_Boost = 2,
} ConverterMode;

/* Definition of the structure to store the filter paremeters*/
XMC_3P3Z_DATA_FIXED_t ctrlFixed;
static ConverterMode u8ConverterModeL = Buck;
static uint32_t u32StartUpCnt = 0;
//static uint32_t u32PwmDutyCycle = 0;
//static uint32_t u32ComplementaryBridgePwmDutyCycle = 0x140;

void TIMER_Interval_Passed_IRQ(void)
{
	volatile uint16_t u16VinResultL = ADC_MEASUREMENT_ADV_GetResult(&ADC_MEASUREMENT_ADV_0_Vin);

	if (mGET_ADC_VALUE_BY_INPUT_VOLTAGE(VOLTAGE_REF) <= (u16VinResultL - mGET_ADC_VALUE_BY_INPUT_VOLTAGE(MODE_HYSTERESYS)))
	{
		u8ConverterModeL = Buck;
	}
	else if (mGET_ADC_VALUE_BY_INPUT_VOLTAGE(VOLTAGE_REF) >= (u16VinResultL + mGET_ADC_VALUE_BY_INPUT_VOLTAGE(MODE_HYSTERESYS)))
	{
		u8ConverterModeL = Boost;
	}
	else
	{
		//u8ConverterModeL ^= 0x1;
		u8ConverterModeL = Buck_Boost;
		//PWM_CCU8_Stop(&PWM_CCU8_0);
		//PWM_CCU8_Stop(&PWM_CCU8_1);
	}

	TIMER_Stop(&TIMER_0);
	TIMER_Clear(&TIMER_0);
	TIMER_ClearEvent(&TIMER_0);
}

void MPPT_Algorithm_IRQ(void)
{
	TIMER_Stop(&TIMER_1);
	TIMER_Clear(&TIMER_1);
	TIMER_ClearEvent(&TIMER_1);
}

/**
 * @brief     ADC conversion complete interrupt handler.
 *
 * @details
 * This ISR is called after the ADC sample has been converted. A 3p3z controller is then run and the
 * output is available in CtrlFloat.m_pOut, which is directly passed to the compare match value 1 (duty cycle)
 *
 * CCU8 is used in count up mode, eg
 *
 *   ADC Trigger                        ADC Trigger
 *      ;                                   :
 *      ;_______                            :________
 *  PWM |    <--|-->                        |     <--|-->
 *  ____|  20%  |___________________________|  20%   |_______
 *      ;                                   :
 *      ;                                   :
 *      ;  2.4us                            :
 *      ;<--------> _______                 :            _______
 *  ISR ;ADC + ISR |       |                :           |       |
 *  ____;__________| 4.9us |________________:___________| 4.9us |_______
 */
void ISR_voltage_control_loop()
{
  /* Applying the filter to the ADC measured value */
  XMC_3P3Z_FilterFixed(&ctrlFixed);

  // 500ms start-up delay
  if (PWM_START_UP_DELAY_CNT >= u32StartUpCnt)
  {
	  u32StartUpCnt++;
  }
  else
  {
	    if (cFalse == TIMER_GetTimerStatus(&TIMER_0))
	    {
	    	TIMER_Start(&TIMER_0);
	    	DIGITAL_IO_SetOutputHigh(&DIGITAL_IO_0);
	    }
	    else
	    {
	    	  if (cFalse != TIMER_GetInterruptStatus(&TIMER_0))
			  {
				  TIMER_Interval_Passed_IRQ();
				  DIGITAL_IO_SetOutputLow(&DIGITAL_IO_0);
			  }
	    }

	    if (cFalse == TIMER_GetTimerStatus(&TIMER_1))
	    {
	    	TIMER_Start(&TIMER_1);
	    	DIGITAL_IO_SetOutputHigh(&DIGITAL_IO_1);
	    }
	    else
	    {
	    	  if (cFalse != TIMER_GetInterruptStatus(&TIMER_1))
			  {
	    		  MPPT_Algorithm_IRQ();
	    		  DIGITAL_IO_SetOutputLow(&DIGITAL_IO_1);
			  }
	    }

	    if (Buck == u8ConverterModeL)
	    {
			/* Updating the compare value 1 of the CCU8 */
			PWM_CCU8_1.ccu8_slice_ptr->CR1S = 0x00;

			/* Updating the compare value 1 of the CCU8 */
			PWM_CCU8_0.ccu8_slice_ptr->CR1S = 0xA0;

			/* Enabling shadow transfer */
			PWM_CCU8_1.ccu8_module_ptr->GCSS |= PWM_CCU8_1_SHADOW_TRANSFER_ENABLE;

			/* Enabling shadow transfer */
			PWM_CCU8_0.ccu8_module_ptr->GCSS |= PWM_CCU8_0_SHADOW_TRANSFER_ENABLE;
		}
		else if (Boost == u8ConverterModeL)
		{
			/* Updating the compare value 1 of the CCU8 */
			PWM_CCU8_0.ccu8_slice_ptr->CR1S = 0x140;

			/* Updating the compare value 1 of the CCU8 */
			PWM_CCU8_1.ccu8_slice_ptr->CR1S = 0xA0;

			/* Enabling shadow transfer */
			PWM_CCU8_0.ccu8_module_ptr->GCSS |= PWM_CCU8_0_SHADOW_TRANSFER_ENABLE;

			/* Enabling shadow transfer */
			PWM_CCU8_1.ccu8_module_ptr->GCSS |= PWM_CCU8_1_SHADOW_TRANSFER_ENABLE;
		}
		else if (Buck_Boost == u8ConverterModeL)
		{
			// Transfer power directly to the output
			/* Updating the compare value 1 of the CCU8 */
			PWM_CCU8_0.ccu8_slice_ptr->CR1S = 0x140;

			/* Updating the compare value 1 of the CCU8 */
			PWM_CCU8_1.ccu8_slice_ptr->CR1S = 0xA0;

			/* Enabling shadow transfer */
			PWM_CCU8_0.ccu8_module_ptr->GCSS |= PWM_CCU8_0_SHADOW_TRANSFER_ENABLE;

			/* Enabling shadow transfer */
			PWM_CCU8_1.ccu8_module_ptr->GCSS |= PWM_CCU8_1_SHADOW_TRANSFER_ENABLE;
		}
    }

    volatile uint16_t u16VoutResultL = ADC_MEASUREMENT_ADV_GetResult(&ADC_MEASUREMENT_ADV_0_Vout);
    volatile uint16_t u16VinResultL = ADC_MEASUREMENT_ADV_GetResult(&ADC_MEASUREMENT_ADV_0_Vin);

  	// Perform overvoltage protection
  	if (mGET_ADC_VALUE_BY_INPUT_VOLTAGE(MAX_INPUT_VOLTAGE) <= u16VinResultL)
  	{
  		// Stop Buck PWM
  		PWM_CCU8_Stop(&PWM_CCU8_0);
  		//PWM_CCU8_0.ccu8_slice_ptr->CR1S = 0x00;
  	}

  	if (mGET_ADC_VALUE_BY_OUTPUT_VOLTAGE(MAX_OUTPUT_VOLTAGE) <= u16VoutResultL)
  	{
  		// Stop Boost PWM - The HD Boost is connected to inverted channel which has LOW level before CMPR match
  		PWM_CCU8_Stop(&PWM_CCU8_1);
  		//PWM_CCU8_1.ccu8_slice_ptr->CR1S = 0x13F;
  	}

  	/*
  	if (PWM_START_UP_DELAY_CNT < u32StartUpCnt)
  	{
		// Mode selection
		if (mGET_ADC_VALUE_BY_INPUT_VOLTAGE(VOLTAGE_REF) <= (u16VinResultL - mGET_ADC_VALUE_BY_INPUT_VOLTAGE(MODE_HYSTERESYS)))
		{
			u8ConverterModeL = Buck;
		}
		else if (mGET_ADC_VALUE_BY_INPUT_VOLTAGE(VOLTAGE_REF) >= (u16VinResultL + mGET_ADC_VALUE_BY_INPUT_VOLTAGE(MODE_HYSTERESYS)))
		{
			u8ConverterModeL = Boost;
		}
		else
		{
			//u8ConverterModeL ^= 0x1;
			u8ConverterModeL = Buck_Boost;
			//PWM_CCU8_Stop(&PWM_CCU8_0);
			//PWM_CCU8_Stop(&PWM_CCU8_1);
		}
  	}*/
}

/**

 * @brief main() - Application entry point
 *
 * <b>Details of function</b><br>
 * This routine is the application entry point. It is invoked by the device startup code. It is responsible for
 * invoking the APP initialization dispatcher routine - DAVE_Init() and hosting the place-holder for user application
 * code.
 */
int main(void)
{
  DAVE_STATUS_t status;

  status = DAVE_Init();           /* Initialization of DAVE APPs  */

  if(status == DAVE_STATUS_FAILURE)
  {
    /* Placeholder for error handler code. The while loop below can be replaced with an user error handler. */
    XMC_DEBUG("DAVE APPs initialization failed\n");

    while(1U)
    {

    }
  }
  /* Filter structure initialization */
  XMC_3P3Z_InitFixed(&ctrlFixed,B0,B1,B2,B3,A1,A2,A3,K,REF,DUTY_TICKS_MIN,DUTY_TICKS_MAX,
		             &VADC_G1->RES[ADC_MEASUREMENT_ADV_0_Vout_handle.ch_handle->result_reg_number]);

  /* ADC trigger signal setting */
  XMC_CCU8_SLICE_SetTimerCompareMatchChannel2(PWM_CCU8_0.ccu8_slice_ptr,TRIGGER_ADC);
  PWM_CCU8_0.ccu8_module_ptr->GCSS= 0x1;

  /* Start PWM */
  PWM_CCU8_Start(&PWM_CCU8_0);
  PWM_CCU8_Start(&PWM_CCU8_1);

  while(1U)
  {

  }
}

